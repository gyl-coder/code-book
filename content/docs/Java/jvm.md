---
title: JVM
linktitle: jvm
type: book
date: "2021-01-02T00:00:00+01:00"

# Prev/next pager order (if `docs_section_pager` enabled in `params.toml`)
weight: 3
---

## JVM 内存模型

Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域。这些区域有各自的用途，以及创建和销毁的时间，有的区域随着虚拟机进程的启动而一直存在，有些区域则是依赖用户线程的启动和结束而建立和销毁。根据《Java虚拟机规范》的规定，Java虚拟机所管理的内存将会包括以下几个运行时数据区域。

![](https://cdn.jsdelivr.net/gh/gyl-coder/bookImgs/java/jvm/7.png)

### 程序计数器

程序计数器是一块较小的内存空间，可以把它看做是当前线程所执行的字节码的行号指示器。在Java虚拟机的概念模型里，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。

Java 虚拟机的多线程是通过线程轮流切换、分配处理器执行时间的方式来实现的，在任何一个时刻，一个处理器都只会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。

### 虚拟机栈

Java 虚拟机栈（Java Virtual Machine Stack），和程序计数器相同它也是线程独享的，生命周期和线程相同。用来描述 Java 方法的执行的内存模型，在每个方法被执行时会创建一个栈帧，用来存储局部变量表、操作栈、动态链接、方法出口等信息。当调用方法时执行入栈，方法返回时执行出栈。

局部变量表存放了编译期可知的各种基本数据类型（boolean、byte、short、int、long、float、double、char）、对象引用（指向对象起始地址的指针）和 returnAddress 类型（指向一条字节码指令的地址）。

局部变量表所需要的的内存在编译期间完成分配。运行期间不会改变局部变量表的大小。

### 本地方法栈

本地方法栈（Native Method Stacks）与虚拟机栈类似，也是线程独享的，并且作用也和虚拟机栈类似。只不过虚拟机栈是为虚拟机中执行的 Java 方法服务的，而本地方法栈则是为虚拟机使用到的本地（Native）方法服务。

### 堆

堆（Java Heap）也叫Java堆或者GC堆，他是线程共享的一块内存区域，也是JVM中占用内存最大的一块区域，Java的大部分对象都存储在这里。
堆大小的值可通过 -Xms 和 -Xmx 来设置（设置最小值和最大值），当堆超过最大值时就会抛出 OOM（OutOfMemoryError）异常。

#### 逃逸分析

JIT（Just In Time Compilation，即时编译 ）优化中的逃逸分析，使得变量可以直接在栈上被分配。

当对象或者是变量在方法中被创建之后，其指针可能被线程所引用，而这个对象就被称作指针逃逸或者是引用逃逸。

比如以下代码中的 sb 对象的逃逸：

```java
public static StringBuffer createString() {
    StringBuffer sb = new StringBuffer();
    sb.append("Java");
    return sb;
}
```

sb 虽然是一个局部变量，但上述代码可以看出，它被直接 return 出去了，因此可能被赋值给了其他变量，并且被完全修改，于是此 sb 就逃逸到了方法外部。

想要 sb 变量不逃逸也很简单，可以改为如下代码：

```java
public static String createString() {
    StringBuffer sb = new StringBuffer();
    sb.append("Java");
    return sb.toString();
}
```

### 方法区

方法区（Method Area） 也被称为非堆区，用于和“Java 堆”的概念进行区分，它也是线程共享的内存区域，用于存储已经被 JVM 加载的类型信息、常量、静态变量、代码缓存等数据。

### 运行时常量池

运行时常量池是方法区的一部分。Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有常量池信息（用于存放编译期生成的各种字面量和符号引用）
既然运行时常量池时方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出 OutOfMemoryError 异常。

JDK1.7及之后版本的 JVM 已经将运行时常量池从方法区中移了出来，在 Java 堆（Heap）中开辟了一块区域存放运行时常量池。

### 直接内存

直接内存并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用。而且也可能导致 OutOfMemoryError 异常出现。

JDK1.4中新加入的 NIO(New Input/Output) 类，引入了一种基于通道（Channel） 与缓存区（Buffer） 的 I/O 方式，它可以直接使用Native函数库直接分配堆外内存，然后通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样就能在一些场景中显著提高性能，因为避免了在 Java 堆和 Native 堆之间来回复制数据。
本机直接内存的分配不会收到 Java 堆的限制，但是，既然是内存就会受到本机总内存大小以及处理器寻址空间的限制。


## 对象创建流程

### 1. 类加载检查

虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程。

### 2. 分配内存

在类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需的内存大小在类加载完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。

内存分配存在两种方式：

1. 指针碰撞
2. 空闲列表

假设Java堆中内存是绝对规整的，所有用过的内存都放在一边，空闲的在另一边，中间有一个指针作为分界点。这种情况下分配内存仅仅就是把指针向空闲空间那边挪动一段对象大小相等的距离。这种分配方式成为“指针碰撞”。

如果java堆中的内存并不规整，已使用的内存和未使用的内存相互交错，那就没有使用指针碰撞了，虚拟机需要维护一个列表，记录那块内存是空闲可用的，分配时从列表中找一块足够大的分配给对象实例。这种分配方式成为“空闲列表”。

选择哪种分配方式取决于内存空间是否规整，内存空间是否规整又取决于使用的垃圾收集器是否拥有压缩整理的功能。因此当使用Serial 或 ParNew等带有Compact过程的收集器时，系统采用的分配方式是指针碰撞。如果使用CMS这种基于Mark-Sweep算法的收集器时，通常采用空闲列表的方式

**内存分配的并发问题**

内存分配在并发情况下并不安全，解决这个问题也有两种方式：

1. 采用CAS + 失败重试
2. 把内存分配的动作按照线程划分到不同的空间中进行，即为每一个线程在Java堆中提前划分一块内存，成为本地线程分配缓存 TLAB

那个线程要分配内存，就在那个线程的TLAB上分配，TLAB用完之后分配新的TLAB时采用加锁的方式。虚拟机是否采用TLAB 可以通过 -XX:+/-UseTLAB参数进行设置。

### 3. 初始化零值

内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。（如果使用TLAB方式，这一过程可以提前至TLAB分配时进行）

### 4. 对象头设置

零值设置完成之后，虚拟机要对对象进行必要的设置。例如，这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄。这些信息都存放在对象头中。

### 5. init

上面四步完成之后，对虚拟机来说，一个新对象就算产生了，但是从Java程序的视角来看，对象的创建才刚开始，<init>方法还没有执行，所有的对象都还是零。一般来说执行new指令之后会接着执行init方法，这样一个对象才算执行完成。

## 对象的内存布局

在 Hotspot 虚拟机中，对象在内存中的布局可以分为 3 块区域：对象头、实例数据和对齐填充。

Hotspot 虚拟机的对象头包括两部分信息，第一部分用于存储对象自身的运行时数据（哈希码、GC 分代年龄、锁状态标志等等），另一部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是那个类的实例。
实例数据部分是对象真正存储的有效信息，也是在程序中所定义的各种类型的字段内容。

对齐填充部分不是必然存在的，也没有什么特别的含义，仅仅起占位作用。 因为 Hotspot 虚拟机的自动内存管理系统要求对象起始地址必须是 8 字节的整数倍，换句话说就是对象的大小必须是 8 字节的整数倍。而对象头部分正好是 8 字节的倍数（1 倍或 2 倍），因此，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。

## 对象的访问定位

建立对象就是为了使用对象，我们的 Java 程序通过栈上的 reference 数据来操作堆上的具体对象。对象的访问方式由虚拟机实现而定，目前主流的访问方式有：句柄 和 直接指针两种

**句柄：** 如果使用句柄的话，那么 Java 堆中将会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息。

**直接指针：** 如果使用直接指针访问，那么 Java 堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而 reference 中存储的直接就是对象的地址。

这两种对象访问方式各有优势。使用句柄来访问的最大好处是 reference 中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而 reference 本身不需要修改。使用直接指针访问方式最大的好处就是速度快，它节省了一次指针定位的时间开销。

## JVM 执行流程

JVM 的执行流程是，首先先把 Java 代码（.java）转化成字节码（.class），然后通过类加载器将字节码加载到内存中，所谓的内存也就是我们上面介绍的运行时数据区，但字节码并不是可以直接交给操作系统执行的机器码，而是一套 JVM 的指令集。这个时候需要使用特定的命令解析器也就是我们俗称的**执行引擎（Execution Engine）**将字节码翻译成可以被底层操作系统执行的指令再去执行，这样就实现了整个 Java 程序的运行，这也是 JVM 的整体执行流程。

## 虚拟机类加载机制

### 类加载机制

[https://gyl-coder.top/java/jvm/jvm-class-loader/](https://gyl-coder.top/java/jvm/jvm-class-loader/)

### 类加载器

[https://gyl-coder.top/java/jvm/jvm-class-loader2/](https://gyl-coder.top/java/jvm/jvm-class-loader2/)
