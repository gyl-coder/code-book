---
# Title, summary, and page position.
linktitle: 网络
summary: network
weight: 1

# Page metadata.
title: 计算机网络
date: "2021-01-08T00:00:00Z"
type: book  # Do not modify.
---

- [ ] 简述 TCP 三次握手以及四次挥手的流程。为什么需要三次握手以及四次挥手？
- [ ] TCP 四次挥手的时候 CLOSE_WAIT 的话怎么处理？
- [ ] TCP四次挥手过程以及所处状态，为什么还需要有 time_wait？
- [ ] TCP 中 SYN 攻击是什么？如何防止？
- [ ] 简述 TCP 的 TIME_WAIT
- [ ] TCP 怎么保证可靠传输？
- [ ] 简述 TCP 协议的延迟 ACK 和累计应答
- [ ] 简述 TCP 滑动窗口以及重传机制
- [ ] 从系统层面上，UDP如何保证尽量可靠？
- [ ] 什么是 TCP 粘包和拆包？
- [ ] TCP 与 UDP 在网络协议中的哪一层，他们之间有什么区别？
- [ ] TCP 中常见的拥塞控制算法有哪些？
- [ ] TCP的拥塞控制具体是怎么实现的？UDP有拥塞控制吗？
- [ ] TCP 的 keepalive 了解吗？说一说它和 HTTP 的 keepalive 的区别？
- [ ] 简述 OSI 七层模型，TCP，IP 属于哪一层？
- [ ] HTTP 与 HTTPS 有哪些区别？
- [ ] 简述 HTTPS 的加密与认证过程
- [ ] HTTP 的方法有哪些？
- [ ] get 和 post 方法的区别
- [ ] 简述常见的 HTTP 状态码的含义（301，304，401，403）
- [ ] 简述 HTTP 1.0，1.1，2.0 的主要区别
- [ ] 什么是跨域，什么情况下会发生跨域请求？
- [ ] 简述 WebSocket 是如何进行传输的
- [ ] 从输入 URL 到展现页面的全过程？
- [ ] DNS 查询服务器的基本流程是什么？DNS 劫持是什么？
- [ ] Cookie 和 Session 的关系和区别是什么？
- [ ] 简述 JWT 的原理和校验机制
- [ ] 简述对称与非对称加密的概念
- [ ] 什么是中间人攻击？如何防止攻击？



## 三次握手

三次握手是 TCP 连接的建立过程。在握手之前，主动打开连接的客户端结束 CLOSE 阶段，被动打开的服务器也结束 CLOSE 阶段，并进入 LISTEN 阶段。随后进入三次握手阶段：

![](https://cdn.jsdelivr.net/gh/gyl-coder/bookImgs/java/network/1.png)

1. 首先客户端向服务器发送一个 SYN 包，并等待服务器确认，其中：

    - 标志位为 SYN，表示请求建立连接；
    - 序号为 Seq = x（x 一般为 1）；
    - 随后客户端进入 SYN-SENT 阶段。

2. 服务器接收到客户端发来的 SYN 包后，对该包进行确认后结束 LISTEN 阶段，并返回一段 TCP 报文，其中：

    - 标志位为 SYN 和 ACK，表示确认客户端的报文 Seq 序号有效，服务器能正常接收客户端发送的数据，并同意创建新连接；
    - 序号为 Seq = y；
    - 确认号为 Ack = x + 1，表示收到客户端的序号 Seq 并将其值加 1 作为自己确认号 Ack 的值，随后服务器端进入 SYN-RECV 阶段。

3. 客户端接收到发送的 SYN + ACK 包后，明确了从客户端到服务器的数据传输是正常的，从而结束 SYN-SENT 阶段。并返回最后一段报文。其中：

    - 标志位为 ACK，表示确认收到服务器端同意连接的信号；
    - 序号为 Seq = x + 1，表示收到服务器端的确认号 Ack，并将其值作为自己的序号值；
    - 确认号为 Ack= y + 1，表示收到服务器端序号 seq，并将其值加 1 作为自己的确认号 Ack 的值。
    - 随后客户端进入 ESTABLISHED。

当服务器端收到来自客户端确认收到服务器数据的报文后，得知从服务器到客户端的数据传输是正常的，从而结束 SYN-RECV 阶段，进入 ESTABLISHED 阶段，从而完成三次握手。

### 如果三次握手的时候每次握手信息对方没有收到会怎么样

若第一次握手服务器未接收到客户端请求建立连接的数据包时，服务器不会进行任何相应的动作，而客户端由于在一段时间内没有收到服务器发来的确认报文， 因此会等待一段时间后重新发送 SYN 同步报文，若仍然没有回应，则重复上述过程直到发送次数超过最大重传次数限制后，建立连接的系统调用会返回 -1。

若第二次握手客户端未接收到服务器回应的 ACK 报文时，客户端会采取第一次握手失败时的动作，这里不再重复，而服务器端此时将阻塞在 accept() 系统调用处等待 client 再次发送 ACK 报文。

若第三次握手服务器未接收到客户端发送过来的 ACK 报文，同样会采取类似于客户端的超时重传机制，若重传次数超过限制后仍然没有回应，则 accept() 系统调用返回 -1，服务器端连接建立失败。但此时客户端认为自己已经连接成功了，因此开始向服务器端发送数据，但是服务器端的 accept() 系统调用已返回，此时没有在监听状态。因此服务器端接收到来自客户端发送来的数据时会发送 RST 报文给 客户端，消除客户端单方面建立连接的状态

### 为什么要进行三次握手？两次握手可以吗？

三次握手的主要目的是确认自己和对方的发送和接收都是正常的，从而保证了双方能够进行可靠通信。若采用两次握手，当第二次握手后就建立连接的话，此时客户端知道服务器能够正常接收到自己发送的数据，而服务器并不知道客户端是否能够收到自己发送的数据。

我们知道网络往往是非理想状态的（存在丢包和延迟），当客户端发起创建连接的请求时，如果服务器直接创建了这个连接并返回包含 SYN、ACK 和 Seq 等内容的数据包给客户端，这个数据包因为网络传输的原因丢失了，丢失之后客户端就一直接收不到返回的数据包。由于客户端可能设置了一个超时时间，一段时间后就关闭了连接建立的请求，再重新发起新的请求，而服务器端是不知道的，如果没有第三次握手告诉服务器客户端能否收到服务器传输的数据的话，服务器端的端口就会一直开着，等到客户端因超时重新发出请求时，服务器就会重新开启一个端口连接。长此以往， 这样的端口越来越多，就会造成服务器开销的浪费。

### 第 2 次握手传回了 ACK，为什么还要传回 SYN

SYN是在建立连接时用到的同步信号。

ACK 是为了告诉客户端发来的数据已经接收无误，我接收到的信息确实就是你所发送的信号了，这表明从客户端到服务端的通信是正常的.

回传SYN则是为了建立并确认从服务端到客户端的通信。

### 如果已经建立了连接，但客户端出现了故障怎么办？

服务器每收到一次客户端的请求后都会重新复位一个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。

### TCP 中 SYN 攻击是什么？如何防止？

在 TCP 建立连接的过程中，因为服务端不确定自己发给客户端的 SYN-ACK 消息或客户端反馈的 ACK 消息是否会丢在半路，所以会给每个待完成的半开连接状态设一个定时器，如果超过时间还没有收到客户端的 ACK 消息，则重新发送一次 SYN-ACK 消息给客户端，直到重试超过一定次数时才会放弃。

服务端为了维持半开连接状态，需要分配内核资源维护半开连接。当攻击者伪造海量的虚假 IP 向服务端发送 SYN 包时，就形成了 SYN FLOOD 攻击。攻击者故意不响应 ACK 消息，导致服务端被大量注定不能完成的半开连接占据，直到资源耗尽，停止响应正常的连接请求。

![](https://cdn.jsdelivr.net/gh/gyl-coder/bookImgs/java/network/3.png)

**防御手段：**

- 直接的方法是提高 TCP 端口容量的同时减少半开连接的资源占用时间，然而该方法只是稍稍提高了防御能力；
- 部署能够辨别恶意 IP 的路由器，将伪造 IP 地址的发送方发送的 SYN 消息过滤掉，该方案作用一般不是太大；

上述两种方法虽然在一定程度上能够提高服务器的防御能力，但是没有从根本上解决服务器资源消耗殆尽的问题，而以下几种方法的出发点都是在发送方发送确认回复后才开始分配传输资源，从而避免服务器资源消耗殆尽。

- SYN Cache：该方法首先构造一个全局 Hash Table，用来缓存系统当前所有的半开连接信息。在 Hash Table 中的每个桶的容量大小是有限制的，当桶满时，会主动丢掉早来的信息。当服务端收到一个 SYN 消息后，会通过一个映射函数生成一个相应的 Key 值，使得当前半连接信息存入相应的桶中。当收到客户端正确的确认报文后，服务端才开始分配传输资源块，并将相应的半开连接信息从表中删除。和服务器传输资源相比，维护表的开销要小得多。

- SYN Cookies：该方案原理和 HTTP Cookies 技术类似，服务端通过特定的算法将半开连接信息编码成序列号或者时间戳，用作服务端给客户端的消息编号，随 SYN-ACK 消息一同返回给连接发起方，这样在连接建立完成前服务端不保存任何信息，直到发送方发送 ACK 确认报文并且服务端成功验证编码信息后，服务端才开始分配传输资源。若请求方是攻击者，则不会向服务端会 ACK 消息，由于未成功建立连接，因此服务端并没有花费任何额外的开销。

然而该方案也存在一些缺点，由于服务端并不保存半开连接状态，因此也就丧失了超时重传的能力，这在一定程度上降低了正常用户的连接成功率。此外，客户端发送给服务端的确认报文存在传输丢失的可能，当 ACK 确认报文丢失时，服务端和客户端会对连接的成功与否产生歧义，此时就需要上层应用采取相应的策略进行处理了。

SYN Proxy：在客户端和服务器之间部署一个代理服务器，类似于防火墙的作用。通过代理服务器与客户端进行建立连接的过程，之后代理服务器充当客户端将成功建立连接的客户端信息发送给服务器。这种方法基本不消耗服务器的资源，但是建立连接的时间变长了（总共需要 6 次握手）。


## 四次挥手

四次挥手即 TCP 连接的释放，这里假设客户端主动释放连接。在挥手之前主动释放连接的客户端结束 ESTABLISHED 阶段，随后开始四次挥手：

![](https://cdn.jsdelivr.net/gh/gyl-coder/bookImgs/java/network/2.png)

1. 首先客户端向服务器发送一段 TCP 报文表明其想要释放 TCP 连接，其中：

    - 标记位为 FIN，表示请求释放连接；
    - 序号为 Seq = u；
    - 随后客户端进入 FIN-WAIT-1 阶段，即半关闭阶段，并且停止向服务端发送通信数据。

2. 服务器接收到客户端请求断开连接的 FIN 报文后，结束 ESTABLISHED 阶段，进入 CLOSE-WAIT 阶段并返回一段 TCP 报文，其中：

    - 标记位为 ACK，表示接收到客户端释放连接的请求；
    - 序号为 Seq = v；
    - 确认号为 Ack = u + 1，表示是在收到客户端报文的基础上，将其序号值加 1 作为本段报文确认号 Ack 的值；
    - 随后服务器开始准备释放服务器端到客户端方向上的连接。

客户端收到服务器发送过来的 TCP 报文后，确认服务器已经收到了客户端连接释放的请求，随后客户端结束 FIN-WAIT-1 阶段，进入 FIN-WAIT-2 阶 - 段。

3. 服务器端在发出 ACK 确认报文后，服务器端会将遗留的待传数据传送给客户端，待传输完成后即经过 CLOSE-WAIT 阶段，便做好了释放服务器端到客户端的连接准备，再次向客户端发出一段 TCP 报文，其中：

    - 标记位为 FIN 和 ACK，表示已经准备好释放连接了；
    - 序号为 Seq = w；
    - 确认号 Ack = u + 1，表示是在收到客户端报文的基础上，将其序号 Seq 的值加 1 作为本段报文确认号 Ack 的值。
    - 随后服务器端结束 CLOSE-WAIT 阶段，进入 LAST-ACK 阶段。并且停止向客户端发送数据。

4. 客户端收到从服务器发来的 TCP 报文，确认了服务器已经做好释放连接的准备，于是结束 FIN-WAIT-2 阶段，进入 TIME-WAIT 阶段，并向服务器发送一段报文，其中：

    - 标记位为 ACK，表示接收到服务器准备好释放连接的信号；
    - 序号为 Seq= u + 1，表示是在已收到服务器报文的基础上，将其确认号 Ack 值作为本段序号的值；
    - 确认号为 Ack= w + 1，表示是在收到了服务器报文的基础上，将其序号 Seq 的值作为本段报文确认号的值。

随后客户端开始在 TIME-WAIT 阶段等待 2 MSL。服务器端收到从客户端发出的 TCP 报文之后结束 LAST-ACK 阶段，进入 CLOSED 阶段。由此正式确认关闭服务器端到客户端方向上的连接。客户端等待完 2 MSL 之后，结束 TIME-WAIT 阶段，进入 CLOSED 阶段，由此完成「四次挥手」。

### 为什么要四次挥手？

释放 TCP 连接时之所以需要四次挥手，是因为 FIN 释放连接报文和 ACK 确认接收报文是分别在两次握手中传输的。 当主动方在数据传送结束后发出连接释放的通知，由于被动方可能还有必要的数据要处理，所以会先返回 ACK 确认收到报文。当被动方也没有数据再发送的时候，则发出连接释放通知，对方确认后才完全关闭TCP连接。

举个例子：A 和 B 打电话，通话即将结束后，A 说“我没啥要说的了”，B回答“我知道了”，但是 B 可能还会有要说的话，A 不能要求 B 跟着自己的节奏结束通话，于是 B 可能又巴拉巴拉说了一通，最后 B 说“我说完了”，A 回答“知道了”，这样通话才算结束。

### CLOSE-WAIT 和 TIME-WAIT 的状态和意义

在服务器收到客户端关闭连接的请求并告诉客户端自己已经成功收到了该请求之后，服务器进入了 CLOSE-WAIT 状态，然而此时有可能服务端还有一些数据没有传输完成，因此不能立即关闭连接，而 CLOSE-WAIT 状态就是为了保证服务器在关闭连接之前将待发送的数据发送完成。

TIME-WAIT 发生在第四次挥手，当客户端向服务端发送 ACK 确认报文后进入该状态，若取消该状态，即客户端在收到服务端的 FIN 报文后立即关闭连接，此时服务端相应的端口并没有关闭，若客户端在相同的端口立即建立新的连接，则有可能接收到上一次连接中残留的数据包，可能会导致不可预料的异常出现。除此之外，假设客户端最后一次发送的 ACK 包在传输的时候丢失了，由于 TCP 协议的超时重传机制，服务端将重发 FIN 报文，若客户端并没有维持 TIME-WAIT 状态而直接关闭的话，当收到服务端重新发送的 FIN 包时，客户端就会用 RST 包来响应服务端，这将会使得对方认为是有错误发生，然而其实只是正常的关闭连接过程，并没有出现异常情况。

### TIME-WAIT 为什么是 2MSL

当客户端发出最后的 ACK 确认报文时，并不能确定服务器端能够收到该段报文。所以客户端在发送完 ACK 确认报文之后，会设置一个时长为 2 MSL 的计时器。MSL（Maximum Segment Lifetime），指一段 TCP 报文在传输过程中的最大生命周期。2 MSL 即是服务器端发出 FIN 报文和客户端发出的 ACK 确认报文所能保持有效的最大时长。

若服务器在 1 MSL 内没有收到客户端发出的 ACK 确认报文，再次向客户端发出 FIN 报文。如果客户端在 2 MSL 内收到了服务器再次发来的 FIN 报文，说明服务器由于一些原因并没有收到客户端发出的 ACK 确认报文。客户端将再次向服务器发出 ACK 确认报文，并重新开始 2 MSL 的计时。

若客户端在 2MSL 内没有再次收到服务器发送的 FIN 报文，则说明服务器正常接收到客户端 ACK 确认报文，客户端可以进入 CLOSE 阶段，即完成四次挥手。

所以客户端要经历 2 MSL 时长的 TIME-WAIT 阶段，为的是确认服务器能否接收到客户端发出的 ACK 确认报文。

### TIME_WAIT 状态会导致什么问题，怎么解决

我们考虑高并发短连接的业务场景，在高并发短连接的 TCP 服务器上，当服务器处理完请求后主动请求关闭连接，这样服务器上会有大量的连接处于 TIME_WAIT 状态，服务器维护每一个连接需要一个 socket，也就是每个连接会占用一个文件描述符，而文件描述符的使用是有上限的，如果持续高并发，会导致一些正常的 连接失败。

**解决方案：**

修改配置或设置 SO_REUSEADDR 套接字，使得服务器处于 TIME-WAIT 状态下的端口能够快速回收和重用。

服务器可以设置 SO_REUSEADDR 套接字选项来通知内核，如果端口被占用，但 TCP 连接位于 TIME_WAIT 状态时可以重用端口。如果你的服务器程序停止后想立即重启，而新的套接字依旧希望使用同一端口，此时 SO_REUSEADDR 选项就可以避免 TIME-WAIT 状态。

也可以采用长连接的方式减少 TCP 的连接与断开，在长连接的业务中往往不需要考虑 TIME-WAIT 状态，但其实在长连接的业务中并发量一般不会太高。

### 有很多 CLOSE-WAIT 怎么解决

首先检查是不是自己的代码问题（看是否服务端程序忘记关闭连接），如果是，则修改代码。

调整系统参数，包括句柄相关参数和 TCP/IP 的参数，一般一个 CLOSE_WAIT 会维持至少 2 个小时的时间，我们可以通过调整参数来缩短这个时间。

## TCP 和 UDP

### TCP 与 UDP 在网络协议中的哪一层，他们之间有什么区别？

传输层

| 类型 | 是否面向连接 | 传输可靠性 | 传输形式   | 传输效率 | 所需资源 | 应用场景           | 首部字节 |
| ---- | ------------ | ---------- | ---------- | -------- | -------- | ------------------ | -------- |
| TCP  | 是           | 可靠       | 字节流     | 慢       | 多       | 文件传输、邮件传输 | 20~60    |
| UDP  | 否           | 不可靠     | 数据报文段 | 快       | 少       | 即时通讯、域名转换 | 8 个字节 |

### TCP 怎么保证可靠传输？

TCP协议保证数据传输可靠性的方式主要有：

- 校验和
- 序列号
- 确认应答
- 超时重传
- 连接管理
- 流量控制
- 拥塞控制

#### 校验和



#### 序列号与确认应答

序列号：TCP传输时将每个字节的数据都进行了编号，这就是序列号。

确认应答：TCP传输的过程中，每次接收方收到数据后，都会对传输方进行确认应答。也就是发送ACK报文。这个ACK报文当中带有对应的确认序列号，告诉发送方，接收到了哪些数据，下一次的数据从哪里发。

序列号的作用不仅仅是应答的作用，有了序列号能够将接收到的数据根据序列号排序，并且去掉重复序列号的数据。这也是TCP传输可靠性的保证之一。

#### 超时重传

在进行TCP传输时，由于确认应答与序列号机制，也就是说发送方发送一部分数据后，都会等待接收方发送的ACK报文，并解析ACK报文，判断数据是否传输成功。但是由于网络问题发送方可能收不到ACK响应。

发送方没有接收到ACK响应的原因有可能是如下两种：

- 数据发送方：数据发送过程中有由于网络问题全体丢包，接收方根本没有收到数据。
- 数据接收方：数据拿到了。但是发送ACK报文的时候由于网络问题，发送失败

TCP引入了`超时重传机制`来解决以上问题。简单的理解就是在发送方发送数据后的一段时候内，如果没有接收到接收方的ACK响应，那么刚刚发送的数据需要重新发送。对应上面说到的两种原因，如果是数据发方的问题，数据重新发送，数据接收方进行响应ACK;如果是数据接收方的问题，数据发送过来之后，接收方根据序列号判断是否是重复数据，如果是直接丢弃，然后继续返回ack响应。

由于TCP传输时保证能够在任何环境下都有一个高性能的通信，因此这个最大超时时间（也就是等待的时间）是动态计算的。

> 重传机制还有以下几种：
> 
> **快速重传**
> 
> 快速重传（Fast Retransmit）机制，它不以时间为驱动，而是以数据驱动重传。
> ![](https://cdn.jsdelivr.net/gh/gyl-coder/bookImgs/java/network/4.png)
> 
> 在上图，发送方发出了 1，2，3，4，5 份数据，第一份 Seq1 先送到了，于是就 Ack 回 2，结果 Seq2 因为某些原因没收到，Seq3 到达了，于是还是 Ack 回 2，后面的 Seq4 > 和 Seq5 都到了，但还是 Ack 回 2，因为 Seq2 还是没有收到，发送端收到了三个 Ack = 2 的确认，知道了 Seq2 还没有收到，就会在定时器过期之前，重传丢失的 Seq2。
> 
> 最后，收到了 Seq2，此时因为 Seq3，Seq4，Seq5 都收到了，于是 Ack 回 6 。
> 
> 所以，快速重传的工作方式是当收到三个相同的 ACK 报文时，会在定时器过期之前，重传丢失的报文段。
> 
> 快速重传机制只解决了一个问题，就是超时时间的问题，但是它依然面临着另外一个问题。就是重传的时候，是重传之前的一个，还是重传所有的问题。
> 
> 比如对于上面的例子，是重传 Seq2 呢？还是重传 Seq2、Seq3、Seq4、Seq5 呢？因为发送端并不清楚这连续的三个 Ack 2 是谁传回来的。
> 
> 为了解决不知道该重传哪些 TCP 报文，于是就有 SACK 方法。
>
> **SACK**
>
> ![](https://cdn.jsdelivr.net/gh/gyl-coder/bookImgs/java/network/5.png)
>
> **Duplicate SACK**
> 
> Duplicate SACK 又称 D-SACK ，其主要使用了 SACK 来告诉「发送方」有哪些数据被重复接收了。
> ![](https://cdn.jsdelivr.net/gh/gyl-coder/bookImgs/java/network/6.png)
> ![](https://cdn.jsdelivr.net/gh/gyl-coder/bookImgs/java/network/7.png)

#### 拥塞控制

在网络出现拥堵时，如果继续发送大量数据包，可能会导致数据包时延、丢失等，这时 TCP 就会重传数据，但是一重传就会导致网络的负担更重，于是会导致更大的延迟以及更多的丢包，这个情况就会进入恶性循环被不断地放大....

拥塞控制，控制的目的就是避免「发送方」的数据填满整个网络。

TCP进行拥塞控制常用的算法有四种：`慢启动`、`拥塞避免`、`快重传`、`快恢复`。

**慢启动**

为了在「发送方」调节所要发送数据的量，定义了一个叫做「拥塞窗口」的概念。TCP为发送方维持一个拥塞窗口，记为cwnd。拥塞窗口是发送方使用的流量控制，接收方声明的接收窗口是接收方使用的流量控制。发送方的发送窗口大小等于这两个窗口中的最小值。（发送窗口 swnd 、接收窗口 rwnd、swnd = min(cwnd, rwnd)）

拥塞窗口的值跟SMSS有关，SMSS为发送的最大报文段长度。

慢启动算法规定：拥塞窗口初始化后，每收到一个对新报文的确认，拥塞窗口就加一个SMSS的大小。拥塞窗口以字节为单位，但是慢启动以SMSS大小为单位增加。按照慢启动算法，经过一轮传输，拥塞窗口就增大一倍，这是一种指数增长的关系。

![](https://cdn.jsdelivr.net/gh/gyl-coder/bookImgs/java/network/8.png)

这里假定拥塞窗口 cwnd 和发送窗口 swnd 相等，下面举个栗子：

- 连接建立完成后，一开始初始化 cwnd = 1 ，表示可以传一个 SMSS 大小的数据。
- 当收到一个 ACK 确认应答后，cwnd 增加 1，于是一次能够发送 2 个
- 当收到 2 个的 ACK 确认应答后， cwnd 增加 2，于是就可以比之前多发2 个，所以这一次能够发送 4 个
- 当这 4 个的 ACK 确认到来的时候，每个确认 cwnd 增加 1， 4 个确认 cwnd 增加 4，于是就可以比之前多发 4 个，所以这一次能够发送 8 个。

**拥塞避免**

慢启动算法除了维持拥塞窗口cwnd变量之外，还维持另一个变量慢启动门限ssthresh。当cwnd以指数增长的形式增长到大于或等于ssthresh时，就不再采用慢启动算法，而是采用拥塞避免算法来进行拥塞控制。

- 当 cwnd < ssthresh 时，使用慢启动算法。
- 当 cwnd >= ssthresh 时，就会使用「拥塞避免算法」。 （一般来说 ssthresh 的大小是 65535 字节。）

拥塞避免算法规定：每次收到一个确认时将cwnd增加 `1/cwnd` 个SMSS。即不再是像慢启动算法那样经过一轮传输cwnd翻倍了，而是经过一轮传输增加一个SMSS。这是一种加性增长的关系。

接上前面的慢启动的栗子，现假定 ssthresh 为 8 ,当 8 个 ACK 应答确认到来时，每个确认增加 1/8，8 个 ACK 确认 cwnd 一共增加 1，于是这一次能够发送 9 个 MSS 大小的数据，变成了线性增长

![](https://cdn.jsdelivr.net/gh/gyl-coder/bookImgs/java/network/9.png)

**快重传**

当网络出现拥塞，也就是会发生数据包重传，重传机制主要有两种：超时重传、快速重传。

当发生了「超时重传」，则就会使用拥塞发生算法。这个时候，ssthresh 和 cwnd 的值会发生变化：

- ssthresh 设为 cwnd/2 
- cwnd 重置为1

接着，就重新开始慢启动，慢启动是会突然减少数据流的。

![](https://cdn.jsdelivr.net/gh/gyl-coder/bookImgs/java/network/10.png)

如果使用的是「快速重传算法」。当接收方发现丢了一个中间包的时候，发送三次前一个包的 ACK，于是发送端就会快速地重传，不必等待超时再重传。

TCP 认为这种情况不严重，因为大部分没丢，只丢了一小部分，则 ssthresh 和 cwnd 变化如下：

- cwnd = cwnd/2 ，也就是设置为原来的一半
- ssthresh = cwnd
- 进入快速恢复算法

**快恢复**

进入快速恢复之前， cwnd 和 ssthresh 已被更新了：

- cwnd = cwnd/2 ，也就是设置为原来的一半;
- ssthresh = cwnd ;

然后，进入快速恢复算法如下：

- 拥塞窗口 cwnd = ssthresh + 3 （ 3 的意思是确认有 3 个数据包被收到了）；
- 重传丢失的数据包；
- 如果再收到重复的 ACK，那么 cwnd 增加 1；
- 如果收到新数据的 ACK 后，把 cwnd 设置为第一步中的 ssthresh 的值，原因是该 ACK 确认了新的数据，说明从 duplicated ACK 时的数据都已收到，该恢复过程已经结束，可以回到恢复之前的状态了，也即再次进入拥塞避免状态；

![](https://cdn.jsdelivr.net/gh/gyl-coder/bookImgs/java/network/11.png)

#### 流量控制

通过TCP连接发送数据，如果发送方发送数据很慢，容易造成资源浪费；如果发送方发送数据过快，接收方来不及接收会造成数据丢失。流量控制就是指在接收方能够接收的范围内，合理而又快速的发送数据。

**基于滑动窗口的流量控制**

利用滑动窗口机制可以实现对发送方的流量控制。在TCP连接建立时，接收方会在确认报文段中给出自己接收窗口的大小。在每次发送确认报文时能够根据情况动态调整接收窗口的大小，并将告知发送方。

在接收方接收窗口为0时，发送方不再发送数据，直到接收方发送确认报文表明窗口大小发生改变。可是这个确认报文不一定能够被发送方接收到，如果一旦该确认报文丢失，双方都将处于等待中，形成死锁。为防止这种情况出现，TCP规定在收到对方接受窗口为0时，启动一个坚持定时器周期性的发送探测报文，以确定对方接收窗口为0的状态是否改变。

另外，TCP标准规定：接收方接收窗口为0时，不再接收正常数据，但是可以接收零窗口探测报文段、确认报文段、携带紧急数据的报文段。

**糊涂窗口综合症**

糊涂窗口综合症是指仅仅有少量数据通过连接进行交换，而不是满长度的报文段。这样会导致网络传输的效率很低。

如果接收缓存已经存满，此时接收方的应用程序每次只从接收缓存中读取少量数据，则接收方的接收窗口会一直保持在一个较低的值，导致发送方每次只能发送少量数据，会导致糊涂窗口综合症。
如果发送方应用程序每次向发送缓存中写入少量数据，TCP选择每次收到数据之后立即发送，也会导致糊涂窗口综合症。

避免糊涂窗口综合症可以从两端采取解决措施：

1. 接收方不通告小窗口。通常的算法是接收方不通告一个比当前窗口大的窗口（可以为0），除非窗口可以增加一个报文段大小（也就是将要接收的MSS）或者可以增加接收方缓存空间 的一半，不论实际有多少。
2. 发送方在存在满长度的报文段或者接收方通告窗口大小一半报文时才发送。

#### 滑动窗口

如果TCP 是每发送一个数据，都要进行一次确认应答。当上一个数据包收到了应答了， 再发送下一个。

![](https://cdn.jsdelivr.net/gh/gyl-coder/bookImgs/java/network/12.png)

这样的传输方式有一个缺点：数据包的往返时间越长，通信的效率就越低。

为解决这个问题，TCP 引入了窗口这个概念。即使在往返时间较长的情况下，它也不会降低网络通信的效率。有了窗口，就可以指定窗口大小，窗口大小就是指无需等待确认应答，而可以继续发送数据的最大值。

窗口的实现实际上是操作系统开辟的一个缓存空间，发送方主机在等到确认应答返回之前，必须在缓冲区中保留已发送的数据。如果按期收到确认应答，此时数据就可以从缓存区清除。

假设窗口大小为 3 个 TCP 段，那么发送方就可以「连续发送」 3 个 TCP 段，并且中途若有 ACK丢失，可以通过「下一个确认应答进行确认」。如下图：

![](https://cdn.jsdelivr.net/gh/gyl-coder/bookImgs/java/network/13.png)

图中的 ACK 600 确认应答报文丢失，也没关系，因为可以通过下一个确认应答进行确认，只要发送方收到了 ACK 700 确认应答，就意味着 700 之前的所有数据「接收方」都收到了。这个模式就叫累计确认或者累计应答。





- [ ]
- [ ] 简述 TCP 协议的延迟 ACK 和累计应答
- [ ] 简述 TCP 滑动窗口以及重传机制
- [ ] 从系统层面上，UDP如何保证尽量可靠？
- [ ] 什么是 TCP 粘包和拆包？
- [ ] 
- [ ] TCP 中常见的拥塞控制算法有哪些？
- [ ] TCP的拥塞控制具体是怎么实现的？UDP有拥塞控制吗？
- [ ] TCP 的 keepalive 了解吗？说一说它和 HTTP 的 keepalive 的区别？
- [ ] 简述 OSI 七层模型，TCP，IP 属于哪一层？